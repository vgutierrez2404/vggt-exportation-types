import colorsys
import numpy as np
import open3d as o3d
import subprocess
import time
from scipy.interpolate import griddata
from sklearn.decomposition import PCA
from scipy.spatial import ConvexHull, Delaunay
from sklearn.neighbors import KDTree    
import concurrent.futures
import copy
from postprocessing_utils.visualization import show_point_cloud  
import matplotlib.path as mpath  

def highlight_and_clean_point_cloud(point_cloud: o3d.geometry.PointCloud):
    """"
    This function does a first step in removing outlier points of the point
    cloud. It identifies the outlier points of the input point cloud and 
    changes their color to blue, in order to be identificable. Then, concatenates
    both point clouds. 

    Input: 
        - point_cloud: o3d.geometry.PointCloud object which is the point cloud
        generated by opensfm. 
    
    Output: 
        - point_cloud_stat: o3d.utility.Vector3dVector which is the "clean" point
        cloud without outliers. 
        - merged_point_cloud: o3d.utility.Vector3dVector which is the input point
        cloud but with the outliers painted as blue (they will be removed with the sky). 
    """

    # Down sampling to reduce the running time:
    point_cloud = point_cloud.voxel_down_sample(voxel_size=0.15)
    print(f"Point cloud has {len(point_cloud.points)} points")

    # pcd_stat, ind_stat = pcd.remove_statistical_outlier(nb_neighbors=20,
    #                                                     std_ratio=1.0)
    point_cloud_stat, index_stat = point_cloud.remove_statistical_outlier(nb_neighbors=80,
                                                        std_ratio=4.0)
    
    # Select the outlier points int the point cloud
    outlier_stat_pcd = point_cloud.select_by_index(index_stat, invert=True)
    # And paint them in blue
    outlier_stat_pcd.paint_uniform_color([0., 0., 1.])

    # Translate to visualize:
    points = np.asarray(point_cloud_stat.points)
    points += [0, 0, 0]
    point_cloud_stat.points = o3d.utility.Vector3dVector(points)

    points_outlier = np.asarray(outlier_stat_pcd.points)
    points_outlier += [0, 0, 0]
    outlier_stat_pcd.points = o3d.utility.Vector3dVector(points_outlier)

    # Concatenate pcd_stat and outliers
    clean_point_cloud_points = np.asarray(point_cloud_stat.points)
    clean_point_cloud_colors = np.asarray(point_cloud_stat.colors)
    outlier_point_cloud_points = np.asarray(outlier_stat_pcd.points)
    outlier_point_cloud_colors = np.zeros((np.size(outlier_point_cloud_points, axis=0), 3))
    outlier_point_cloud_colors += [0,0,1]

    # Not sure about this step...
    cnctd_points_point_clouds = np.concatenate((clean_point_cloud_points, outlier_point_cloud_points))
    cnctd_colors_point_clouds = np.concatenate((clean_point_cloud_colors, outlier_point_cloud_colors))

    merged_point_cloud = o3d.geometry.PointCloud()
    merged_point_cloud.points = o3d.utility.Vector3dVector(cnctd_points_point_clouds)
    merged_point_cloud.colors = o3d.utility.Vector3dVector(cnctd_colors_point_clouds)

    return point_cloud_stat, merged_point_cloud

def rgb_to_hsv(rgb:np.array) -> np.array:
    """ 
    Convert an array of RGB color values to HSV color values.

    Input:
        rgb: a np.ndarray array of shape (n, 3), where each row represents
            an RGB color with three floating-point values (red, green, blue).

    Output:
        hsv: a np.ndarray array of the same shape as the input "rgb" array,
            but with the colors converted to the HSV color space.
    
    """
    hsv = np.zeros_like(rgb)
    for i in range(rgb.shape[0]):
        hsv[i] = colorsys.rgb_to_hsv(rgb[i, 0], rgb[i, 1], rgb[i, 2])

    return hsv


def remove_sky_points(point_cloud:o3d.geometry.PointCloud):
    """
    Removes blues from the point cloud (since highlight_and_clean_point_cloud 
    converts the outliers into blue points of the point cloud). 

    Input: 
        - point_cloud: original point cloud with outliers highlighted as blue
    
    Return: 
        - filtered_point_cloud: point cloud without outliers and sky 
        (as well as points can be statistically taken out of the sky). 
    """
    points_point_cloud = np.asarray(point_cloud.points)
    colors_point_cloud = np.asarray(point_cloud.colors)

    hsv = rgb_to_hsv(colors_point_cloud)
    h_values = hsv[:, 0]
    s_values = hsv[:, 1]

    filtered_indices = np.where(~((h_values > 0.5) & (h_values < 0.75) & (s_values > 0.1)))
    points_point_cloud = points_point_cloud[filtered_indices]
    colors_point_cloud = colors_point_cloud[filtered_indices]

    filtered_point_cloud = o3d.geometry.PointCloud()
    filtered_point_cloud.points = o3d.utility.Vector3dVector(points_point_cloud)
    filtered_point_cloud.colors = o3d.utility.Vector3dVector(colors_point_cloud)

    return filtered_point_cloud

def add_floor_to_point_cloud(point_cloud: o3d.geometry.PointCloud, output_point_cloud_file:str=None) -> o3d.geometry.PointCloud:
    """ 
    Adds a floor to the given point cloud and saves the resulting point cloud to a file.
    
    The function computes a floor plane based on the bounds of the input point cloud, adds a margin to each side,
    and creates a meshgrid to represent the floor. It then combines the original point cloud with the floor points
    and saves the combined point cloud to the specified output file.

    Inputs:
        - point_cloud (o3d.geometry.PointCloud): The input point cloud to which the floor will be added.
        - output_point_cloud_file (str): The file path where the resulting point cloud with the floor will be saved.

    """

    # Añadimos un 20 % de margen a cada lado
    marginX = (point_cloud.get_max_bound()[0] - point_cloud.get_min_bound()[0]) * 0.2
    marginY = (point_cloud.get_max_bound()[1] - point_cloud.get_min_bound()[1]) * 0.2

    # Computes a meshgrid for the point cloud with dimension (1000,1000)
    xx_mesh_1, yy_mesh_1 = np.meshgrid(np.linspace(point_cloud.get_min_bound()[0] - marginX, point_cloud.get_max_bound()[0] + marginX, 1000),
                         np.linspace(point_cloud.get_min_bound()[1] - marginY, point_cloud.get_max_bound()[1] + marginY, 1000))

    # 
    limits_x = np.linspace(point_cloud.get_min_bound()[0] - marginX, point_cloud.get_max_bound()[0] + marginX, 220)
    limits_y = np.linspace(point_cloud.get_min_bound()[1] - marginY, point_cloud.get_max_bound()[1] + marginY, 220)

    points_point_cloud = np.asarray(point_cloud.points)

    h, _, _ = np.histogram2d(points_point_cloud[:, 0], points_point_cloud[:, 1], bins=[limits_x, limits_y])
    data_histogram = h.T
    x_lim = limits_x[:-1] + np.diff(limits_x) / 2
    y_lim = limits_y[:-1] + np.diff(limits_y) / 2

    xx_mesh_2, yy_mesh_2 = np.meshgrid(x_lim, y_lim) # -> why is doing a second meshgrid?

    DD = griddata((xx_mesh_2.flatten(), yy_mesh_2.flatten()), data_histogram.flatten(), (xx_mesh_1, yy_mesh_1), method='linear')
    DD[DD > 20] = np.nan

    indices = np.isnan(DD)
    FLOOR = np.column_stack((xx_mesh_1[~indices], yy_mesh_1[~indices], np.zeros(np.count_nonzero(~indices)))).tolist()

    # esto es lo que añadi yo para que el suelo este a la altura del punto más bajo, lo cual no tiene mucho sentido 
    # Lo que habría que hacer es fitear un plano a x puntos más bajos. 
    points_point_cloud[:,2] = points_point_cloud[:,2] + abs(min(points_point_cloud[:,2]))

    points_point_cloud = np.asarray(point_cloud.points)
    colors_point_cloud = np.asarray(point_cloud.colors)
    color_floor = np.repeat(np.array([[1, 0, 1]], dtype=np.float64), len(FLOOR), axis=0)
    points_floor_point_cloud = np.vstack((points_point_cloud, FLOOR))
    colors_floor_point_cloud = np.vstack((colors_point_cloud, color_floor))

    floor_and_point_cloud = o3d.geometry.PointCloud()
    floor_and_point_cloud.points = o3d.utility.Vector3dVector(points_floor_point_cloud)
    floor_and_point_cloud.colors = o3d.utility.Vector3dVector(colors_floor_point_cloud)

    if output_point_cloud_file:
        # Just save the file if a path is provided
        o3d.io.write_point_cloud(output_point_cloud_file, floor_and_point_cloud)

    return floor_and_point_cloud


def pdal_poisson_filter(depth:int, input_file:str, output_file:str)-> None:
    """
    Executes a Poisson filtering in the sparse reconstruction in order to make
    it dense. 
    Other options that can be used in the command can be found in: 
    https://pdal.io/en/stable/stages/filters.poisson.html

    Inputs: 
        - depth: (integer) maximum depth of the tree used for reconstruction.
        - input_file: 
        - output_file: 
    """
    command = f'pdal translate -i "{input_file}" -o "{output_file}" poisson --filters.poisson.depth={depth} --verbose 4'
    print(command)
    
    try:
        output_cmd = subprocess.run(command, shell=True, capture_output=True, text=True, check=True)

        standard_output = output_cmd .stdout
        error_code = output_cmd .returncode

        if standard_output:
            print(standard_output)

        if error_code != 0:
            print(f"The PDAL command returned an exit code of {error_code}. An error may have occurred.")

    except subprocess.CalledProcessError as e:
        print(f"Error executing the PDAL command: {e}")

    except Exception as e:
        print(f"Unexpected error: {e}")

def get_point_cloud_bounding_box(point_cloud:o3d.geometry.PointCloud): 
    """
    Returns the bounding box of the given point cloud. 
    """
    min_bound = np.min(np.asarray(point_cloud.points), axis=0)
    max_bound = np.max(np.asarray(point_cloud.points), axis=0)

    return o3d.geometry.AxisAlignedBoundingBox(min_bound, max_bound)


def filtering_spatial_grid(bin_size:int, bounding_box:o3d.geometry.AxisAlignedBoundingBox, point_cloud:o3d.geometry.PointCloud):  

    """
    The goal is to create "voxels" or cubes inside the region and then filter 
    by density of the points inside the cube.   
    """
    start_time = time.time()

    x_range = float(bounding_box.max_bound[0] - bounding_box.min_bound[0])
    y_range = float(bounding_box.max_bound[1] - bounding_box.min_bound[1])
    z_range = float(bounding_box.max_bound[2] - bounding_box.min_bound[2])
    n_iter_x = int(np.ceil(x_range / bin_size))
    n_iter_y = int(np.ceil(y_range / bin_size))
    n_iter_z = int(np.ceil(z_range / bin_size))


    min_points_threshold = 20  # Define a minimum number of points threshold

    points = np.asarray(point_cloud.points)
    colors = np.asarray(point_cloud.colors)

    filtered_points = []
    filtered_colors = []

    for i in range(n_iter_x):
        for j in range(n_iter_y):
            for k in range(n_iter_z):
                x_min = bounding_box.min_bound[0] + i * bin_size
                x_max = x_min + bin_size
                y_min = bounding_box.min_bound[1] + j * bin_size
                y_max = y_min + bin_size
                z_min = bounding_box.min_bound[2] + k * bin_size
                z_max = z_min + bin_size

                mask = (
                    (points[:, 0] >= x_min) & (points[:, 0] < x_max) &
                    (points[:, 1] >= y_min) & (points[:, 1] < y_max) &
                    (points[:, 2] >= z_min) & (points[:, 2] < z_max)
                )

                if np.sum(mask) >= min_points_threshold:
                    filtered_points.append(points[mask])
                    filtered_colors.append(colors[mask])

    if filtered_points:
        filtered_points = np.vstack(filtered_points)
        filtered_colors = np.vstack(filtered_colors)
    else:
        filtered_points = np.empty((0, 3))
        filtered_colors = np.empty((0, 3))

    filtered_point_cloud = o3d.geometry.PointCloud()
    filtered_point_cloud.points = o3d.utility.Vector3dVector(filtered_points)
    filtered_point_cloud.colors = o3d.utility.Vector3dVector(filtered_colors)
    
    end_time = time.time()

    print(f"After filtering we have removed {len(point_cloud.points) - len(filtered_point_cloud.points)} points from the point cloud")
    print(f"Elapsed time in the filtering process: {end_time - start_time} seconds")

    return filtered_point_cloud
     
def filtering_spatial_grid_parallelized(bin_size:int, bounding_box:o3d.geometry.AxisAlignedBoundingBox, point_cloud:o3d.geometry.PointCloud):  

    """
    The goal is to create "voxels" or cubes inside the region and then filter 
    by density of the points inside the cube. This function uses parallelization
    to speed up the process.
    """
    start_time = time.time()

    x_range = float(bounding_box.max_bound[0] - bounding_box.min_bound[0])
    y_range = float(bounding_box.max_bound[1] - bounding_box.min_bound[1])
    z_range = float(bounding_box.max_bound[2] - bounding_box.min_bound[2])
    n_iter_x = int(np.ceil(x_range / bin_size))
    n_iter_y = int(np.ceil(y_range / bin_size))
    n_iter_z = int(np.ceil(z_range / bin_size))

    min_points_threshold = 20  # Define a minimum number of points threshold

    points = np.asarray(point_cloud.points)
    colors = np.asarray(point_cloud.colors)

    filtered_points = []
    filtered_colors = []

    def process_voxel(i, j, k):
        x_min = bounding_box.min_bound[0] + i * bin_size
        x_max = x_min + bin_size
        y_min = bounding_box.min_bound[1] + j * bin_size
        y_max = y_min + bin_size
        z_min = bounding_box.min_bound[2] + k * bin_size
        z_max = z_min + bin_size

        mask = (
            (points[:, 0] >= x_min) & (points[:, 0] < x_max) &
            (points[:, 1] >= y_min) & (points[:, 1] < y_max) &
            (points[:, 2] >= z_min) & (points[:, 2] < z_max)
        )

        if np.sum(mask) >= min_points_threshold:
            return points[mask], colors[mask]
        else:
            return None, None

    with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
        futures = [
            executor.submit(process_voxel, i, j, k)
            for i in range(n_iter_x)
            for j in range(n_iter_y)
            for k in range(n_iter_z)
        ]

        for future in concurrent.futures.as_completed(futures):
            voxel_points, voxel_colors = future.result()
            if voxel_points is not None:
                filtered_points.append(voxel_points)
                filtered_colors.append(voxel_colors)

    if filtered_points:
        filtered_points = np.vstack(filtered_points)
        filtered_colors = np.vstack(filtered_colors)
    else:
        filtered_points = np.empty((0, 3))
        filtered_colors = np.empty((0, 3))

    filtered_point_cloud = o3d.geometry.PointCloud()
    filtered_point_cloud.points = o3d.utility.Vector3dVector(filtered_points)
    filtered_point_cloud.colors = o3d.utility.Vector3dVector(filtered_colors)
    
    end_time = time.time()

    print(f"After filtering we have removed {len(point_cloud.points) - len(filtered_point_cloud.points)} points from the point cloud")
    print(f"Elapsed time in the filtering process: {end_time - start_time} seconds")

    return filtered_point_cloud

def kdtree_filtering(k:int, distance_threshold:float, point_cloud:o3d.geometry.PointCloud):
    """
    This function uses the KDTree algorithm to filter the point cloud by removing
    the points that are far away from their k nearest neighbors.

    Inputs:
        - k: (int) the number of nearest neighbors to consider when filtering the point cloud.
        - distance_threshold: (float) the maximum distance allowed between a point and its k-th nearest neighbor.
        - point_cloud: (o3d.geometry.PointCloud) the input point cloud to be filtered.

    Returns:
        - filtered_point_cloud: (o3d.geometry.PointCloud) the filtered point cloud with the points that are far away from their k nearest neighbors removed.
    """

    points = np.asarray(point_cloud.points) 
    colors = np.asanyarray(point_cloud.colors) 

    #define the tree that will  be used. 
    print(f"Starting points in the point cloud: {len(point_cloud.points)} \n")
    tree = KDTree(points)

    start_time = time.time()    
    distance, index = tree.query(points, k)
    end_time = time.time()  
    print(f"Computed distances to neighbors in: {end_time - start_time} seconds\n ")
    # print("Some verifications: \n ")
    # print(f"Shape of distances: {distance.shape}\n")
    # print(f"Shape of indices: {index.shape}\n")   
    # print(f"Distances of the 5 closes distances: {distance[:5]} \n")
    # print(f"Indices of the 5 closes distances: {index[:5]} \n")

    max_values_distance = np.max(distance, axis=0)
    # print(f"Maximum values of each column: {max_values_distance}")

    # Removing the values that are far away from the k-th nearest neighbor
    start_time = time.time()
    points = points[distance[:, k-1] < distance_threshold]
    colors = colors[distance[:, k-1] < distance_threshold]  
    end_time = time.time()
    print(f"remove time: {end_time - start_time} seconds")
    point_cloud.points = o3d.utility.Vector3dVector(points) 
    point_cloud.colors = o3d.utility.Vector3dVector(colors) 

    print(f"Points in the point cloud after removing far away points: {len(point_cloud.points)}")

    return point_cloud


def fit_plane_svd(point_cloud:o3d.geometry.PointCloud, n_points: int, roof:bool = False) -> o3d.geometry.PointCloud: 

    """
    Fits a plane to the n_points with the lowest z value in the point cloud using Singular Value Decomposition (SVD).


    Inputs:

        - point_cloud: (o3d.geometry.PointCloud) The input point cloud to which the plane will be fitted.
        - n_points: (int) The number of points with the lowest z value to use for fitting the plane.
    
    Returns:
    
        - floor_point_cloud: (o3d.geometry.PointCloud) The input point cloud with the fitted plane added to it.

    """

    # To manipulate the points in the point cloud they must be converted into numpy arrays. 
    points = np.asarray(point_cloud.points) 
    colors = np.asarray(point_cloud.colors)

    # I will only use the n_points with the lowest z values to fit the plane. 
    sorted_indices = np.argsort(points[:, 2]) # returns the indices of the sorted array 
    selected_points = points[sorted_indices[:n_points]]      
    # get the indices of the points selected from the cloud 
    selected_indices = sorted_indices[:n_points]
    
    # If instead of floor we want to fit a roof... This may not be useful
    if roof: 
        selected_points = points[sorted_indices[-n_points:]]        
        selected_indices = sorted_indices[-n_points:] 

    # now select the colors of the selected indices 
    selected_colors = colors[selected_indices]

    # First we need to compute the centroid of the selected points  
    centroid = np.mean(selected_points, axis=0) 
    centered_points = selected_points - centroid

    U,s,Vt = np.linalg.svd(centered_points)

    # extract the normal vector from the last row of Vt -> last row represents the direction of least variance int he data. 

    a, b, c = Vt[2,:]

    d = -(a*centroid[0] + b*centroid[1] + c*centroid[2])    

    ##########################################
    #  Plane equation: a*x + b*y + c*z + d = 0
    ##########################################
    # Basis vectors 
    u = Vt[0,:]
    v = Vt[1,:]

    # This way the minimum and maximum values dont have to lie inside the point cloud 
    # s_proj = centered_points @ u 
    # t_proj = centered_points @ v    

    # s_min, s_max = s_proj.min(), s_proj.max()   
    # t_min, t_max = t_proj.min(), t_proj.max()

    # This is the way to go in order to have a plane that lies in all the points of the point cloud 
    borders = point_cloud.get_axis_aligned_bounding_box()  
    corners = np.asarray(borders.get_box_points())     

    centered_corners = corners - centroid
    s_corners = centered_corners @ u 
    t_corners = centered_corners @ v 

    s_min, s_max = s_corners.min(), s_corners.max()
    t_min, t_max = t_corners.min(), t_corners.max() 

    s = np.linspace(s_min, s_max, 100)
    t = np.linspace(t_min, t_max, 100)
    grid_s, grid_t = np.meshgrid(s, t, indexing='ij')

    x = centroid[0] + grid_s*u[0] + grid_t*v[0]
    y = centroid[1] + grid_s*u[1] + grid_t*v[1]
    z = centroid[2] + grid_s*u[2] + grid_t*v[2] 
    
    plane = np.column_stack((x.flatten(), y.flatten(), z.flatten())) 

    plane_and_point_cloud = o3d.geometry.PointCloud()
    plane_and_point_cloud.points = o3d.utility.Vector3dVector(np.vstack((point_cloud.points, plane)))
    plane_and_point_cloud.colors = o3d.utility.Vector3dVector(np.vstack((point_cloud.colors, (np.tile([0, 0, 1], (len(plane), 1))))))

    only_plane_point_cloud = o3d.geometry.PointCloud()
    only_plane_point_cloud.points = o3d.utility.Vector3dVector(plane)
    only_plane_point_cloud.colors = o3d.utility.Vector3dVector(np.tile([0,0,1], (len(plane),1)))
    
    return plane_and_point_cloud, only_plane_point_cloud    

def interpolate_voronoi(point_cloud): 
    from scipy.spatial import Voronoi, voronoi_plot_2d
    import  matplotlib.pyplot as plt 
    # projection in the xy plane 
    points = np.asarray(point_cloud.points)
    colors = np.asarray(point_cloud.colors)

    points[:,2] = 0
    points_array = np.column_stack((points[:,0], points[:,1]))
    voronoi_points = Voronoi(points_array)

    # lets remove the regions of the outside 
    # filtered_regions = [region for region in voronoi_points.regions if -1 not in region and len(region) > 0]
    # filtered_vertices = [voronoi_points.vertices[region] for region in filtered_regions]
   
    fig, ax = plt.subplots(figsize=(6, 6))

    # Plot full Voronoi diagram (including infinite regions)
    voronoi_plot_2d(voronoi_points, ax=ax, show_vertices=False, line_colors='gray')

    # Filter out regions that contain -1 (infinite regions)
    filtered_regions = [region for region in voronoi_points.regions if -1 not in region and len(region) > 0]

    # Get valid ridge vertices and plot them
    for region in filtered_regions:
        polygon = [voronoi_points.vertices[i] for i in region]
        polygon = np.array(polygon)
        ax.fill(*zip(*polygon), alpha=0.4, edgecolor='black')  # Fill finite regions

    # Plot original points
    ax.plot(points[:, 0], points[:, 1], 'ro', label="Voronoi Points")

    plt.legend()
    plt.title("Voronoi Diagram without Infinite Regions")
    plt.show()
    projected_point_cloud = o3d.geometry.PointCloud()
    projected_point_cloud.points = o3d.utility.Vector3dVector(points)
    projected_point_cloud.colors = o3d.utility.Vector3dVector(colors)

    show_point_cloud(projected_point_cloud)

def fit_plane(point_cloud: o3d.geometry.PointCloud): 
    
    # Load your point cloud (assuming you already have it in a variable called 'pcd')
    # If not, you can load it from a file:
    # pcd = o3d.io.read_point_cloud("your_point_cloud.ply")

    # 1. Find the topmost points to fit a plane
    points = np.asarray(point_cloud.points)

    # Sort points by height (assuming z is height)
    z_values = points[:, 2]  # Get z coordinates
    height_threshold = np.percentile(z_values, 95)  # Use top 10% of points for plane fitting
    top_points_indices = np.where(z_values > height_threshold)[0]
    top_points = points[top_points_indices]

    # 2. Fit a plane to these top points using PCA
    pca = PCA(n_components=3)
    pca.fit(top_points)
    normal = pca.components_[2]  # The third component should be the normal to the plane

    # Ensure the normal points upward
    if normal[2] < 0:
        normal = -normal

    # Find a point on the plane (centroid of top points)
    point_on_plane = np.mean(top_points, axis=0)

    # 3. Get the plane equation: ax + by + cz + d = 0
    a, b, c = normal
    d = -(a * point_on_plane[0] + b * point_on_plane[1] + c * point_on_plane[2])

    # 4. Find the boundary of the hole at the top
    # Project all points to 2D (onto a plane perpendicular to the normal)
    # First, find perpendicular vectors to the normal
    u = np.array([1, 0, 0])
    if abs(np.dot(u, normal)) > 0.9:
        u = np.array([0, 1, 0])
    v = np.cross(normal, u)
    u = np.cross(v, normal)
    u = u / np.linalg.norm(u)
    v = v / np.linalg.norm(v)

    # Project top points to 2D
    points_2d = np.column_stack([
        np.dot(top_points - point_on_plane, u),
        np.dot(top_points - point_on_plane, v)
    ])

    # 5. Compute convex hull of the projected points
    hull = ConvexHull(points_2d)

    # 6. Generate a grid of points inside the hull to fill the top
    min_x, max_x = np.min(points_2d[:, 0]), np.max(points_2d[:, 0])
    min_y, max_y = np.min(points_2d[:, 1]), np.max(points_2d[:, 1])

    # Grid resolution - adjust as needed for your point cloud density
    resolution = 0.1
    x_range = np.arange(min_x, max_x, resolution)
    y_range = np.arange(min_y, max_y, resolution)

    grid_points_2d = []
    for x in x_range:
        for y in y_range:
            grid_points_2d.append([x, y])

    grid_points_2d = np.array(grid_points_2d)

    # Function to check if a point is inside the convex hull
    def point_in_hull(point, hull, tolerance=1e-12):
        return all(
            (np.dot(eq[:-1], point) + eq[-1] <= tolerance)
            for eq in hull.equations
        )

    # Filter points inside the hull
    inside_points_2d = np.array([p for p in grid_points_2d if point_in_hull(p, hull)])

    # 7. Project these 2D points back to 3D on the plane
    top_fill_points = []
    for p in inside_points_2d:
        # Start from the point on plane and add u and v components
        point_3d = point_on_plane + p[0] * u + p[1] * v
        # Adjust to ensure it's exactly on the plane (optional)
        # Using plane equation: ax + by + cz + d = 0 -> cz = -ax - by - d
        if abs(c) > 1e-10:  # Avoid division by zero
            point_3d[2] = (-a * point_3d[0] - b * point_3d[1] - d) / c
        top_fill_points.append(point_3d)

    top_fill_points = np.array(top_fill_points)

    # 8. Create a new point cloud with these points
    top_fill_pcd = o3d.geometry.PointCloud()
    top_fill_pcd.points = o3d.utility.Vector3dVector(top_fill_points)
    top_fill_pcd.paint_uniform_color([1, 0, 0])  # Color red to distinguish from original

    # For the top fill points, all normals should point upward (same as plane normal)
    top_fill_normals = np.tile(normal, (len(top_fill_points), 1))
    top_fill_pcd.normals = o3d.utility.Vector3dVector(top_fill_normals)

    # 9. Combine with original point cloud
    combined_pcd = point_cloud + top_fill_pcd

    # 10. Estimate normals for the original point cloud if they don't exist
    if not combined_pcd.has_normals():
        print("Estimating normals for the original point cloud...")
        combined_pcd.estimate_normals(
            search_param=o3d.geometry.KDTreeSearchParamHybrid(radius=0.1, max_nn=30)
        )
        # Orient normals consistently (optional but recommended)
        combined_pcd.orient_normals_consistent_tangent_plane(k=20)

    # 11. Ensure normals are consistently oriented (point outward)
    # This is crucial for proper volume calculation
    combined_pcd.orient_normals_towards_camera_location(camera_location=np.array([0, 0, 10]))

    # Visualize to check the result (with normals)
    o3d.visualization.draw_geometries([combined_pcd], point_show_normal=True)

    # 12. Now you can generate a mesh from the combined point cloud with proper normals
    # For example, using Poisson surface reconstruction
    with o3d.utility.VerbosityContextManager(o3d.utility.VerbosityLevel.Debug) as cm:
        mesh, densities = o3d.geometry.TriangleMesh.create_from_point_cloud_poisson(
            combined_pcd, depth=9)

    # Clean the mesh (optional)
    mesh.remove_degenerate_triangles()
    mesh.remove_duplicated_triangles()
    mesh.remove_duplicated_vertices()
    mesh.remove_non_manifold_edges()

    o3d.visualization.draw_geometries([mesh])
    # Calculate volume
    # volume = mesh.get_volume()
    # print(f"Estimated volume: {volume} cubic units")

def fit_plane_top_bottom(point_cloud, add_roof=True, add_floor=False, roof_percentile=95, 
                       floor_percentile=10, grid_resolution=0.1, 
                       normal_radius=0.1, normal_max_nn=30, shrink_factor=0.95):

    points = np.asarray(point_cloud.points)
    
    # Create a copy of the original point cloud
    combined_pcd = copy.deepcopy(point_cloud)
    # Ensure the original point cloud has normals
    if not combined_pcd.has_normals():
        print("Estimating normals for the original point cloud...")
        combined_pcd.estimate_normals(
            search_param=o3d.geometry.KDTreeSearchParamHybrid(
                radius=normal_radius, max_nn=normal_max_nn)
        )
        # Orient normals consistently
        combined_pcd.orient_normals_consistent_tangent_plane(k=20)
    
    z_values = points[:, 2]
    
    if add_roof:
        # Get the top points of the point cloud based on a percentil 
        height_threshold = np.percentile(z_values, roof_percentile)
        top_points_indices = np.where(z_values > height_threshold)[0]
        top_points = points[top_points_indices]
        
        roof_pcd = generate_cap_points(top_points, "roof", grid_resolution, shrink_factor)
        
        combined_pcd += roof_pcd
    
    if add_floor:
        # Get the bottom points of the point cloud based on a percentil 
        height_threshold = np.percentile(z_values, floor_percentile)
        bottom_points_indices = np.where(z_values < height_threshold)[0]
        bottom_points = points[bottom_points_indices]
        
        # for floor dont apply shrink factor
        shrink_factor = 1.25
        floor_pcd = generate_cap_points(bottom_points, "floor", grid_resolution, shrink_factor)
        
        # Combine with the existing point cloud
        combined_pcd += floor_pcd
    

    combined_pcd.orient_normals_towards_camera_location(camera_location=np.array([0, 0, 10]))

    BALL_PIVOTING = False # Different types of algorithms for the computation of the mesh can be used. 
    # By default the used one is the Poisson. 
    if BALL_PIVOTING: 
        distances = combined_pcd.compute_nearest_neighbor_distance()
        avg_dist = np.mean(distances)
        radii = [0.1*avg_dist, 0.5*avg_dist, 1*avg_dist, 2*avg_dist] 
        r = o3d.utility.DoubleVector(radii)
        mesh = o3d.geometry.TriangleMesh.create_from_point_cloud_ball_pivoting(combined_pcd, r)
        
    else:
        mesh, _ = o3d.geometry.TriangleMesh.create_from_point_cloud_poisson(combined_pcd, depth=6)
 

    mesh.remove_degenerate_triangles()
    mesh.remove_duplicated_triangles()
    mesh.remove_duplicated_vertices()
    mesh.remove_non_manifold_edges()
    
    return combined_pcd, mesh

def generate_cap_points(boundary_points, cap_type, grid_resolution=0.1, shrink_factor=0.95):


    pca = PCA(n_components=3)
    pca.fit(boundary_points)
    normal = pca.components_[2]  # The third vector of the pca is orthogonal to the other 2. 
    
    # Ensure normal is pointing in the right direction
    if cap_type == "roof" and normal[2] < 0:
        normal = -normal
    elif cap_type == "floor" and normal[2] > 0:
        normal = -normal
    
    # Find a point on the plane (centroid of boundary points)
    point_on_plane = np.mean(boundary_points, axis=0)
    
    # Plane equation: ax + by + cz + d = 0
    a, b, c = normal
    d = -(a * point_on_plane[0] + b * point_on_plane[1] + c * point_on_plane[2])
    
    # Find perpendicular vectors to the normal for projection
    u = np.array([1, 0, 0])
    if abs(np.dot(u, normal)) > 0.9:
        u = np.array([0, 1, 0])
    v = np.cross(normal, u)
    u = np.cross(v, normal)
    u = u / np.linalg.norm(u)
    v = v / np.linalg.norm(v)
    
    # Project boundary points to 2D
    points_2d = np.column_stack([
        np.dot(boundary_points - point_on_plane, u),
        np.dot(boundary_points - point_on_plane, v)
    ])
    
    # Compute alpha shape (or concave hull) instead of convex hull
    # First get the boundary points using alpha shape approximation with Delaunay triangulation
    tri = Delaunay(points_2d)
    
    # Function to check if a point is on the boundary
    # This uses the fact that boundary points are part of exactly one triangle
    edge_points = {}
    for simplex in tri.simplices:
        for i in range(3):
            # Get the edge vertices
            edge = sorted([simplex[i], simplex[(i+1)%3]])
            edge_tuple = tuple(edge)
            # Count the occurrences of each edge
            if edge_tuple in edge_points:
                edge_points[edge_tuple] += 1
            else:
                edge_points[edge_tuple] = 1
    
    # Edges that appear only once are on the boundary
    boundary_edges = [edge for edge, count in edge_points.items() if count == 1]
    
    # Extract unique vertices from boundary edges
    boundary_vertices = set()
    for edge in boundary_edges:
        boundary_vertices.add(edge[0])
        boundary_vertices.add(edge[1])
    
    # Get the boundary points
    boundary_points_2d = points_2d[list(boundary_vertices)]
    
    # Sort boundary points to form a polygon
    # Find the centroid
    centroid = np.mean(boundary_points_2d, axis=0)
    
    # Sort points by polar angle around centroid
    angles = np.arctan2(boundary_points_2d[:, 1] - centroid[1], 
                        boundary_points_2d[:, 0] - centroid[0])
    sort_indices = np.argsort(angles)
    sorted_boundary = boundary_points_2d[sort_indices]
    
    # Shrink the boundary to avoid salients
    # Move each point towards the centroid by the shrink factor
    shrunk_boundary = centroid + shrink_factor * (sorted_boundary - centroid)
    
    # Create a polygon path for testing points
    path = mpath.Path(shrunk_boundary)
    
    # Generate a grid of points inside the boundary
    min_x, max_x = np.min(points_2d[:, 0]), np.max(points_2d[:, 0])
    min_y, max_y = np.min(points_2d[:, 1]), np.max(points_2d[:, 1])
    
    x_range = np.arange(min_x, max_x, grid_resolution)
    y_range = np.arange(min_y, max_y, grid_resolution)
    
    grid_points_2d = []
    for x in x_range:
        for y in y_range:
            grid_points_2d.append([x, y])
    
    grid_points_2d = np.array(grid_points_2d)
    
    # Filter points inside the shrunk boundary
    mask = path.contains_points(grid_points_2d)
    inside_points_2d = grid_points_2d[mask]
    
    # Project these 2D points back to 3D on the plane
    cap_points = []
    for p in inside_points_2d:
        # Start from the point on plane and add u and v components
        point_3d = point_on_plane + p[0] * u + p[1] * v
        # Adjust to ensure it's exactly on the plane
        if abs(c) > 1e-10:  # Avoid division by zero
            point_3d[2] = (-a * point_3d[0] - b * point_3d[1] - d) / c
        cap_points.append(point_3d)
    
    cap_points = np.array(cap_points)
    
    # Create a new point cloud with these points
    cap_pcd = o3d.geometry.PointCloud()
    cap_pcd.points = o3d.utility.Vector3dVector(cap_points)
    
    # Paint the generated planes in red 
    cap_pcd.paint_uniform_color([1, 0, 0])  

    # Set normals for all cap points
    cap_normals = np.tile(normal, (len(cap_points), 1))
    cap_pcd.normals = o3d.utility.Vector3dVector(cap_normals)
    
    return cap_pcd
